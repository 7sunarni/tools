This test checks the behavior of the 'add test for FUNC' code action.

-- flags --
-ignore_extra_diags

-- go.mod --
module golang.org/lsptests/addtest

go 1.18

-- settings.json --
{
	"addTestSourceCodeAction": true
}

-- withcopyright/copyright.go --
// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build go1.23

// Package main is for lsp test.
package main

func Foo(in string) string {return in} //@codeactionedit("Foo", "source.addTest", with_copyright)

-- @with_copyright/withcopyright/copyright_test.go --
@@ -0,0 +1,22 @@
+// Copyright 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main_test
+
+func TestFoo(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := main.Foo(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: Foo() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- withoutcopyright/copyright.go --
//go:build go1.23

// Package copyright is for lsp test.
package copyright

func Foo(in string) string {return in} //@codeactionedit("Foo", "source.addTest", without_copyright)

-- @without_copyright/withoutcopyright/copyright_test.go --
@@ -0,0 +1,18 @@
+package copyright_test
+
+func TestFoo(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := copyright.Foo(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: Foo() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- missingtestfile/missingtestfile.go --
package main

func ExportedFunction(in string) string {return in} //@codeactionedit("ExportedFunction", "source.addTest", missing_test_file_exported_function)

type Bar struct {}

func (*Bar) ExportedMethod(in string) string {return in} //@codeactionedit("ExportedMethod", "source.addTest", missing_test_file_exported_recv_exported_method)

-- @missing_test_file_exported_function/missingtestfile/missingtestfile_test.go --
@@ -0,0 +1,18 @@
+package main_test
+
+func TestExportedFunction(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := main.ExportedFunction(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: ExportedFunction() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @missing_test_file_exported_recv_exported_method/missingtestfile/missingtestfile_test.go --
@@ -0,0 +1,18 @@
+package main_test
+
+func TestBar_ExportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := ExportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: ExportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- xpackagetestfile/xpackagetestfile.go --
package main

func ExportedFunction(in string) string {return in} //@codeactionedit("ExportedFunction", "source.addTest", xpackage_exported_function)
func unexportedFunction(in string) string {return in} //@codeactionedit("unexportedFunction", "source.addTest", xpackage_unexported_function)

type Bar struct {}

func (*Bar) ExportedMethod(in string) string {return in} //@codeactionedit("ExportedMethod", "source.addTest", xpackage_exported_recv_exported_method)
func (*Bar) unexportedMethod(in string) string {return in} //@codeactionedit("unexportedMethod", "source.addTest", xpackage_exported_recv_unexported_method)

type foo struct {}

func (*foo) ExportedMethod(in string) string {return in} //@codeactionedit("ExportedMethod", "source.addTest", xpackage_unexported_recv_exported_method)
func (*foo) unexportedMethod(in string) string {return in} //@codeactionedit("unexportedMethod", "source.addTest", xpackage_unexported_recv_unexported_method)

-- xpackagetestfile/xpackagetestfile_test.go --
package main

-- @xpackage_exported_function/xpackagetestfile/xpackagetestfile_test.go --
@@ -3 +3,16 @@
+func TestExportedFunction(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := ExportedFunction(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: ExportedFunction() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @xpackage_unexported_function/xpackagetestfile/xpackagetestfile_test.go --
@@ -3 +3,16 @@
+func Test_unexportedFunction(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := unexportedFunction(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: unexportedFunction() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @xpackage_exported_recv_exported_method/xpackagetestfile/xpackagetestfile_test.go --
@@ -3 +3,16 @@
+func TestBar_ExportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := ExportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: ExportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @xpackage_exported_recv_unexported_method/xpackagetestfile/xpackagetestfile_test.go --
@@ -3 +3,16 @@
+func TestBar_unexportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := unexportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: unexportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @xpackage_unexported_recv_exported_method/xpackagetestfile/xpackagetestfile_test.go --
@@ -3 +3,16 @@
+func Test_foo_ExportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := ExportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: ExportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @xpackage_unexported_recv_unexported_method/xpackagetestfile/xpackagetestfile_test.go --
@@ -3 +3,16 @@
+func Test_foo_unexportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := unexportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: unexportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- aliasreceiver/aliasreceiver.go --
package main

type bar struct {}
type middle1 = bar
type middle2 = middle1
type middle3 = middle2
type Bar = middle3

func (*Bar) ExportedMethod(in string) string {return in} //@codeactionedit("ExportedMethod", "source.addTest", pointer_receiver_exported_method)
func (*Bar) unexportedMethod(in string) string {return in} //@codeactionedit("unexportedMethod", "source.addTest", pointer_receiver_unexported_method)

type bar2 struct {}
type middle4 = bar2
type middle5 = middle4
type middle6 = middle5
type foo = *middle6

func (foo) ExportedMethod(in string) string {return in} //@codeactionedit("ExportedMethod", "source.addTest", alias_receiver_exported_method)
func (foo) unexportedMethod(in string) string {return in} //@codeactionedit("unexportedMethod", "source.addTest", alias_receiver_unexported_method)

-- aliasreceiver/aliasreceiver_test.go --
package main

-- @pointer_receiver_exported_method/aliasreceiver/aliasreceiver_test.go --
@@ -3 +3,16 @@
+func TestBar_ExportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := ExportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: ExportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @pointer_receiver_unexported_method/aliasreceiver/aliasreceiver_test.go --
@@ -3 +3,16 @@
+func TestBar_unexportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := unexportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: unexportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @alias_receiver_exported_method/aliasreceiver/aliasreceiver_test.go --
@@ -3 +3,16 @@
+func Test_foo_ExportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := ExportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: ExportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- @alias_receiver_unexported_method/aliasreceiver/aliasreceiver_test.go --
@@ -3 +3,16 @@
+func Test_foo_unexportedMethod(t *testing.T) {
+  tests := []struct {
+    name string // description of this test case
+    arg string
+    want string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got := unexportedMethod(tt.arg)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: unexportedMethod() = %v, want %v", tt.name, got, tt.want)
+    }
+  }
+}
-- multiinputoutput/multiinputoutput.go --
package main

func Foo(in, in1, in2, in3 string) (out, out1, out2 string) {return in, in, in} //@codeactionedit("Foo", "source.addTest", multi_input_output)

-- @multi_input_output/multiinputoutput/multiinputoutput_test.go --
@@ -0,0 +1,32 @@
+package main_test
+
+func TestFoo(t *testing.T) {
+  type args struct {
+    in string
+    in2 string
+    in3 string
+    in4 string
+  }
+  tests := []struct {
+    name string // description of this test case
+    args args
+    want string
+    want2 string
+    want3 string
+  }{
+    // TODO: Add test cases.
+  }
+  for _, tt := range tests {
+    got, got2, got3 := main.Foo(tt.args.in, tt.args.in2, tt.args.in3, tt.args.in4)
+    // TODO: update the condition below to compare got with tt.want.
+    if true {
+      t.Errorf("%s: Foo() = %v, want %v", tt.name, got, tt.want)
+    }
+    if true {
+      t.Errorf("%s: Foo() = %v, want %v", tt.name, got2, tt.want2)
+    }
+    if true {
+      t.Errorf("%s: Foo() = %v, want %v", tt.name, got3, tt.want3)
+    }
+  }
+}
